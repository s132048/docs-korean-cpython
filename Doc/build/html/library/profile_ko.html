
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>4.1. 파이썬 프로파일러 &#8212; 파이썬 3.8.0a0 documentation</title>
    <link rel="stylesheet" href="../_static/pydoctheme.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="../_static/sidebar.js"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within 파이썬 3.8.0a0 documentation"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="About these documents" href="../about.html" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="copyright" title="Copyright" href="../copyright.html" />
    <link rel="next" title="27.5. timeit — Measure execution time of small code snippets" href="timeit.html" />
    <link rel="prev" title="27.3. pdb — The Python Debugger" href="pdb.html" />
    <link rel="shortcut icon" type="image/png" href="../_static/py.png" />
    <link rel="canonical" href="https://docs.python.org/3/library/profile_ko.html" />
    
    <script type="text/javascript" src="../_static/copybutton.js"></script>
    
    
    
 

  </head><body>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="timeit.html" title="27.5. timeit — Measure execution time of small code snippets"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="pdb.html" title="27.3. pdb — The Python Debugger"
             accesskey="P">previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">3.8.0a0 문서</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index_ko.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="debug_ko.html" accesskey="U">4. 디버깅과 프로파일링</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="profile">
<span id="id1"></span><h1>4.1. 파이썬 프로파일러<a class="headerlink" href="#profile" title="Permalink to this headline">¶</a></h1>
<p><strong>Source code:</strong> <a class="reference external" href="https://github.com/VeranosTech/docs-korean-cpython/tree/gh-pages/Lib/profile.py">Lib/profile.py</a> and <a class="reference external" href="https://github.com/VeranosTech/docs-korean-cpython/tree/gh-pages/Lib/pstats.py">Lib/pstats.py</a></p>
<hr class="docutils" />
<div class="section" id="profiler-introduction">
<span id="id2"></span><h2>4.1.1. 프로파일러 소개<a class="headerlink" href="#profiler-introduction" title="Permalink to this headline">¶</a></h2>
<p id="index-0"><a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>와 <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>는 파이썬 프로그램을
<em class="dfn">결정론적 프로파일링(deterministic profiling)</em>하기 위한 것이다.
A <em class="dfn">프로파일(profile)</em>은 프로그램의 각 부분이 얼마나 자주, 그리고 얼마나 오랫동안
실행되는지를 묘사한 통계 집합이다.
이 통계는 <a class="reference internal" href="#module-pstats" title="pstats: 프로파일러와 사용하기 위한 통계 객체."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pstats</span></code></a>모듈을 사용하여 리포트 형태로 만들 수 있다.</p>
<p>파이썬 표준 라이브러리는 동일한 프로파일링 인터페이스를 가진 두 개의 다른 구현을 제공한다.:</p>
<ol class="arabic simple">
<li><a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>는 대부분의 사용자에게 추천한다.
오랫동안 실행되는 프로그램에 적합하도록 오버헤드를 줄인 C 익스텐션(extension)이다.
Brett Rosen과 Ted Czotter가 만든 <code class="xref py py-mod docutils literal notranslate"><span class="pre">lsprof</span></code>에 기반하고 있다.</li>
<li><a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>는 <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>의 인터페이스를 흉내낸 순수 파이썬 모듈로
프로그램에 추가되는 오버헤드가 크다.
프로파일러를 어떻게든 확장해보려고 할 때 이 모듈을 사용하면 일이 쉬워질 수 있다.
Jim Roskind가 설계하고 구현하였다.</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">프로파일러 모듈은 주어진 프로그램의 실행 프로필을 제공하도록 설계된 것이지
벤치마킹 목적으로 만들어지지 않았다. (벤치마크용으로는 <a class="reference internal" href="timeit.html#module-timeit" title="timeit: Measure the execution time of small code snippets."><code class="xref py py-mod docutils literal notranslate"><span class="pre">timeit</span></code></a>이 적합하다.)
특히 파이썬 코드와 C를 비교하여 벤치마킹할 경우, 프로파일러가 파이썬 코드에는
오버헤드를 주고 C-레벨 함수에는 영향이 없으므로 C 코드가 파이썬 코드보다 빠르게
보인다.</p>
</div>
</div>
<div class="section" id="profile-instant">
<span id="id3"></span><h2>4.1.2. 즉석 사용자 매뉴얼<a class="headerlink" href="#profile-instant" title="Permalink to this headline">¶</a></h2>
<p>이 절은 매뉴얼 전체를 읽고 싶어하지 않은 사용자를 위한 절이다.
아주 간단한 개요만 제공하고 지금 있는 애플리케이션을 일단 프로파일링해 볼 수 있도록 한다.</p>
<p>인수를 하나만 가지는 함수를 프로파일링하려면 다음처럼 한다.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cProfile</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="n">cProfile</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;re.compile(&quot;foo|bar&quot;)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>(만약 시스템에서 <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>가 동작하지않으면 대신 <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>를 쓸 수 있다.)</p>
<p>위와 같이 <a class="reference internal" href="re.html#re.compile" title="re.compile"><code class="xref py py-func docutils literal notranslate"><span class="pre">re.compile()</span></code></a>를 실행하면 다음처럼 프로파일 결과를 출력한다:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span>      <span class="mi">197</span> <span class="n">function</span> <span class="n">calls</span> <span class="p">(</span><span class="mi">192</span> <span class="n">primitive</span> <span class="n">calls</span><span class="p">)</span> <span class="ow">in</span> <span class="mf">0.002</span> <span class="n">seconds</span>

<span class="n">Ordered</span> <span class="n">by</span><span class="p">:</span> <span class="n">standard</span> <span class="n">name</span>

<span class="n">ncalls</span>  <span class="n">tottime</span>  <span class="n">percall</span>  <span class="n">cumtime</span>  <span class="n">percall</span> <span class="n">filename</span><span class="p">:</span><span class="n">lineno</span><span class="p">(</span><span class="n">function</span><span class="p">)</span>
     <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.001</span>    <span class="mf">0.001</span> <span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">1</span><span class="p">(</span><span class="o">&lt;</span><span class="n">module</span><span class="o">&gt;</span><span class="p">)</span>
     <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.001</span>    <span class="mf">0.001</span> <span class="n">re</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">212</span><span class="p">(</span><span class="nb">compile</span><span class="p">)</span>
     <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.001</span>    <span class="mf">0.001</span> <span class="n">re</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">268</span><span class="p">(</span><span class="n">_compile</span><span class="p">)</span>
     <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span> <span class="n">sre_compile</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">172</span><span class="p">(</span><span class="n">_compile_charset</span><span class="p">)</span>
     <span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span> <span class="n">sre_compile</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">201</span><span class="p">(</span><span class="n">_optimize_charset</span><span class="p">)</span>
     <span class="mi">4</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span> <span class="n">sre_compile</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">25</span><span class="p">(</span><span class="n">_identityfunction</span><span class="p">)</span>
   <span class="mi">3</span><span class="o">/</span><span class="mi">1</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span>    <span class="mf">0.000</span> <span class="n">sre_compile</span><span class="o">.</span><span class="n">py</span><span class="p">:</span><span class="mi">33</span><span class="p">(</span><span class="n">_compile</span><span class="p">)</span>
</pre></div>
</div>
<p>첫줄은 197개의 함수호출이 있었다는 것을 보인다. 이 중에서 192개는 <em class="dfn">primitive</em>
즉, 재귀(recursion)에 의한 것이 아니다.
다음 줄의 <code class="docutils literal notranslate"><span class="pre">Ordered</span> <span class="pre">by:</span> <span class="pre">standard</span> <span class="pre">name</span></code> 표시는 결과가 가장 오른쪽 열의 문자열을 기준으로
정렬되었다는 뜻이다.
각 열의 의미는 다음과 같다.:</p>
<dl class="docutils">
<dt>ncalls</dt>
<dd>함수 호출 횟수</dd>
<dt>tottime</dt>
<dd>해당 함수에서 사용된 총 시간(하위 함수 호출에 소요된 시간은 제외한다.)</dd>
<dt>percall</dt>
<dd><code class="docutils literal notranslate"><span class="pre">tottime</span></code>을 <code class="docutils literal notranslate"><span class="pre">ncalls</span></code>로 나눈 값</dd>
<dt>cumtime</dt>
<dd>해당 함수와 모든 하위 함수에서 (함수 호출 시작부터 종료까지) 소비된 시간의 누적.
이 수치는 재귀함수에서도 정확한 값이다.</dd>
<dt>percall</dt>
<dd><code class="docutils literal notranslate"><span class="pre">cumtime</span></code>을 primitive 호출 횟수로 나눈 값</dd>
<dt>filename:lineno(function)</dt>
<dd>각 함수에 대한 정보</dd>
</dl>
<p>첫번째 열의 숫자 두 개(예를 들어 <code class="docutils literal notranslate"><span class="pre">3/1</span></code>)는 함수의 재귀 횟수를 뜻한다.
두번째 숫자는 primitive 호출 횟수이고 앞의 숫자는 전체 호출 횟수이다.
재귀함수가 아니면 두 값이 같으므로 하나만 표시된다.</p>
<p>프로파일 종료시에 결과를 인쇄하지 않고 파일에 저장하려면 <code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code>에
파일 이름을 명시한다.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cProfile</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="n">cProfile</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s1">&#39;re.compile(&quot;foo|bar&quot;)&#39;</span><span class="p">,</span> <span class="s1">&#39;restats&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">pstats.Stats</span></code></a> 클래스는 이 파일의 프로파일 결과를 읽어 여러가지 형태로 바꿀 수 있다.
예를 들어:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">-</span><span class="n">m</span> <span class="n">cProfile</span> <span class="p">[</span><span class="o">-</span><span class="n">o</span> <span class="n">output_file</span><span class="p">]</span> <span class="p">[</span><span class="o">-</span><span class="n">s</span> <span class="n">sort_order</span><span class="p">]</span> <span class="p">(</span><span class="o">-</span><span class="n">m</span> <span class="n">module</span> <span class="o">|</span> <span class="n">myscript</span><span class="o">.</span><span class="n">py</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">-o</span></code> 프로파일 결과를 표준출력이 아닌 파일에 쓴다.</p>
<p><code class="docutils literal notranslate"><span class="pre">-s</span></code> <a class="reference internal" href="#pstats.Stats.sort_stats" title="pstats.Stats.sort_stats"><code class="xref py py-func docutils literal notranslate"><span class="pre">sort_stats()</span></code></a> 결과를 해당 기준으로 정렬한다. <code class="docutils literal notranslate"><span class="pre">-o</span></code>이 없을 때만 가능하다.</p>
<p><code class="docutils literal notranslate"><span class="pre">-m</span></code> 스크립트 대신에 모듈을 제공한다.</p>
<blockquote>
<div><div class="versionadded">
<p><span class="versionmodified">New in version 3.7: </span><code class="docutils literal notranslate"><span class="pre">-m</span></code> 옵션 추가.</p>
</div>
</div></blockquote>
<p><a class="reference internal" href="#module-pstats" title="pstats: 프로파일러와 사용하기 위한 통계 객체."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pstats</span></code></a> 모듈의 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 클래스는 프로파일 결과 파일에 저장된 데이터를
조작하고 인쇄하는 다양한 메서드를 가지고 있다.:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pstats</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">pstats</span><span class="o">.</span><span class="n">Stats</span><span class="p">(</span><span class="s1">&#39;restats&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">strip_dirs</span><span class="p">()</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">()</span>
</pre></div>
</div>
<p>위 예시에서서 사용된 메서드들은 다음과 같은 역할을 한다.
<a class="reference internal" href="#pstats.Stats.strip_dirs" title="pstats.Stats.strip_dirs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">strip_dirs()</span></code></a> 메서드는 모든 모듈 이름으로부터 불필요한 경로명을 삭제한다.
<a class="reference internal" href="#pstats.Stats.sort_stats" title="pstats.Stats.sort_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_stats()</span></code></a> 메서드는 인쇄되는 표준 모듈/행/이름 문자열에 따라 모든 항목을 정렬한다.
<a class="reference internal" href="profile.html#pstats.Stats.print_stats" title="pstats.Stats.print_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">print_stats()</span></code></a> 메서드는 모든 통계를 인쇄한다. 다음과 같은 정 호출을 시도할 수 있다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="s1">&#39;name&#39;</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">print_stats</span><span class="p">()</span>
</pre></div>
</div>
<p>첫번째 호출은 실제로 함수명에 따라 목록을 정렬하고 두번째 호출이 통계를 인쇄한다.
다음과 같은 흥미로운 호출도 시험해볼 수 있다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="s1">&#39;cumulative&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>이 호출은 프로파일을 함수의 누적 시간에 따라 정렬하고 가장 중요한 열개의 라인만을 인쇄한다.
어떤 알고리즘이 시간을 잡아먹는지 알고 싶다면 위 예시를 사용할 수 있다.</p>
<p>어떤 함수가 루프를 많이 돌아 긴 시간을 잡아먹는지 알고 싶다면 다음을 사용한다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>각 함수가 사용한 시간에 따라 정렬되고 상위 열개 함수를 인쇄한다.</p>
<p>다음 호출도 시도해볼 수 있다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="s1">&#39;file&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="s1">&#39;__init__&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>이 호출은 모든 통계를 파일명에 따라 정렬하고 init 메서드 클래스와 관련된 통계만을 인쇄한다.
(<code class="docutils literal notranslate"><span class="pre">__init__</span></code>을 인수로 넣었기 때문이다.) 마지막 예시로 다음 호출을 시도해보자.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="s1">&#39;cumulative&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">print_stats</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;init&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>이 호출은 모든 통계를 기본 키가 되는 시간과 보조키가 되는 누적 시간으로 정렬하고 통계의 일부를 인쇄한다.
자세히 설명하자면 전체 목록은 원래 목록에서 50%로 추려지고 (인수: <code class="docutils literal notranslate"><span class="pre">.5</span></code>) <code class="docutils literal notranslate"><span class="pre">init</span></code>을 포함하는 행만이 남는다.
마지막으로 남은 목록이 인쇄된다.</p>
<p>위 함수 중 어떤 함수가 호출되는지도 알 수 있다. (<code class="docutils literal notranslate"><span class="pre">p</span></code>는 마지막 기준에 따라 정렬된다.)</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">print_callers</span><span class="p">(</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="s1">&#39;init&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>위 호출로 나열된 각 함수의 호출기 목록을 볼 수 있다.</p>
<p>더 많은 기능을 원한다면 매뉴얼을 읽어보거나 다음 함수가 하는 일에 대해서 알아본다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">p</span><span class="o">.</span><span class="n">print_callees</span><span class="p">()</span>
<span class="n">p</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;restats&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>스크립트로 호출되는 <a class="reference internal" href="#module-pstats" title="pstats: 프로파일러와 사용하기 위한 통계 객체."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pstats</span></code></a> 모듈은 프로파일 덤프를 읽고 조사하는 통계 브라우저다.
이 모듈은 <a class="reference internal" href="cmd.html#module-cmd" title="cmd: Build line-oriented command interpreters."><code class="xref py py-mod docutils literal notranslate"><span class="pre">cmd</span></code></a>를 사용해 구현된 간단한 행 지향 인터페이스와 대화형 인터페이스를 갖는다.</p>
</div>
<div class="section" id="module-cProfile">
<span id="profile-cprofile"></span><h2>4.1.3. <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>, <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a> 모듈 레퍼런스<a class="headerlink" href="#module-cProfile" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-profile"></span><p><a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>과 <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a> 모듈은 모두 다음 함수를 제공한다.</p>
<dl class="function">
<dt id="profile.run">
<code class="descclassname">profile.</code><code class="descname">run</code><span class="sig-paren">(</span><em>command</em>, <em>filename=None</em>, <em>sort=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.run" title="Permalink to this definition">¶</a></dt>
<dd><p>이 함수는 <a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 함수로 보내질 수 있는 단일 인수와 선택 인수 파일명을 인수로 받는다.
모든 경우에 이 루틴은 다음을 실행한다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">exec</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="n">__main__</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">,</span> <span class="n">__main__</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>
</pre></div>
</div>
<p>실행에서 프로파일링 통계를 모은다. <code class="docutils literal notranslate"><span class="pre">filename</span></code> 인수가 없으면 함수는 자동으로 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a>
인스턴스를 생성하고 간단한 프로파일링 리포트를 인쇄한다. <code class="docutils literal notranslate"><span class="pre">sort</span></code> 인수가 지정되면 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a>
인스턴스로 보내져 결과값을 정렬하는 방법을 결정한다.</p>
</dd></dl>

<dl class="function">
<dt id="profile.runctx">
<code class="descclassname">profile.</code><code class="descname">runctx</code><span class="sig-paren">(</span><em>command</em>, <em>globals</em>, <em>locals</em>, <em>filename=None</em>, <em>sort=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.runctx" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="docutils">
<dt>이 함수는 <a class="reference internal" href="#profile.run" title="profile.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> 함수와 비슷하지만 <em>command</em> 문자열을 위한 전역, 지역 딕셔너리를 제공하는 인수가 추가되어 있다.</dt>
<dd><p class="first">이 루틴은 다음을 실행한다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">exec</span><span class="p">(</span><span class="n">command</span><span class="p">,</span> <span class="nb">globals</span><span class="p">,</span> <span class="nb">locals</span><span class="p">)</span>
</pre></div>
</div>
<p class="last"><a class="reference internal" href="#profile.run" title="profile.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">run()</span></code></a> 함수를 실행한 것처럼 프로파일링 통계를 수집한다.</p>
</dd>
</dl>
<dl class="class">
<dt id="profile.Profile">
<em class="property">class </em><code class="descclassname">profile.</code><code class="descname">Profile</code><span class="sig-paren">(</span><em>timer=None</em>, <em>timeunit=0.0</em>, <em>subcalls=True</em>, <em>builtins=True</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile" title="Permalink to this definition">¶</a></dt>
<dd><p>이 클래스는 일반적으로 <code class="xref py py-func docutils literal notranslate"><span class="pre">cProfile.run()</span></code> 함수가 제공하는 것보다 더 정밀하게 프로파일링을 제어해야 할 때에만 사용된다.</p>
<p>코드가 실행되는데 필요한 시간을 측정하기 위한 커스텀 타이머를 <em>timer</em> 인수에 줄 수 있다.
이 타이머는 반드시 현재 시간을 나타내는 하나의 숫자만을 반환하는 함수가 되어야 한다.
숫자가 정수면 <em>timeunit</em> 인수는 시간의 각 단위가 갖는 지속 시간을 지정하는 승수를 지정한다.
예를 들어, 타이머가 천 초 단위로 측정되는 시간을 반환하면 <a href="#id4"><span class="problematic" id="id5">*</span></a>timeunit*은 <code class="docutils literal notranslate"><span class="pre">.001</span></code>가 된다.</p>
<p><a class="reference internal" href="#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">Profile</span></code></a> 클래스를 직접 사용하면 프로파일 데이터를 파일에 작성하지 않고 프로파일 결과를 포매팅할 수 있다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">cProfile</span><span class="o">,</span> <span class="nn">pstats</span><span class="o">,</span> <span class="nn">io</span>
<span class="n">pr</span> <span class="o">=</span> <span class="n">cProfile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span>
<span class="n">pr</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
<span class="c1"># ... do something ...</span>
<span class="n">pr</span><span class="o">.</span><span class="n">disable</span><span class="p">()</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
<span class="n">sortby</span> <span class="o">=</span> <span class="s1">&#39;cumulative&#39;</span>
<span class="n">ps</span> <span class="o">=</span> <span class="n">pstats</span><span class="o">.</span><span class="n">Stats</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">sort_stats</span><span class="p">(</span><span class="n">sortby</span><span class="p">)</span>
<span class="n">ps</span><span class="o">.</span><span class="n">print_stats</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>
</pre></div>
</div>
<dl class="method">
<dt id="profile.Profile.enable">
<code class="descname">enable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.enable" title="Permalink to this definition">¶</a></dt>
<dd><p>프로파일링 데이터 수집을 시작한다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.disable">
<code class="descname">disable</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.disable" title="Permalink to this definition">¶</a></dt>
<dd><p>프로파일링 데이터 수집을 중단한다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.create_stats">
<code class="descname">create_stats</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.create_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>프로파일링 데이터 수집을 중단하고 결과를 현재 프로파일로 내부에 기록한다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.print_stats">
<code class="descname">print_stats</code><span class="sig-paren">(</span><em>sort=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.print_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>현재 프로파일에 기반해 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 객체를 생성하고 stdout으로 결과를 인쇄한다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.dump_stats">
<code class="descname">dump_stats</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.dump_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>현재 프로파일 결과를 <a href="#id6"><span class="problematic" id="id7">*</span></a>filename*에 작성한다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.run">
<code class="descname">run</code><span class="sig-paren">(</span><em>cmd</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.run" title="Permalink to this definition">¶</a></dt>
<dd><p>cmd를 <a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a>를 통해 명령을 프로파일링한다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.runctx">
<code class="descname">runctx</code><span class="sig-paren">(</span><em>cmd</em>, <em>globals</em>, <em>locals</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.runctx" title="Permalink to this definition">¶</a></dt>
<dd><p>cmd를 지정된 전역, 지역 변수로 <a class="reference internal" href="functions.html#exec" title="exec"><code class="xref py py-func docutils literal notranslate"><span class="pre">exec()</span></code></a> 를 통해 프로파일링한다.</p>
</dd></dl>

<dl class="method">
<dt id="profile.Profile.runcall">
<code class="descname">runcall</code><span class="sig-paren">(</span><em>func</em>, <em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#profile.Profile.runcall" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal notranslate"><span class="pre">func(*args,</span> <span class="pre">**kwargs)</span></code>를 프로파일링 한다.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="stats">
<span id="profile-stats"></span><h2>4.1.4. <code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code> 클래스<a class="headerlink" href="#stats" title="Permalink to this headline">¶</a></h2>
<p>프로파일러 데이터 분석은 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 클래스를 사용해 이루어진다.</p>
<span class="target" id="module-pstats"></span><dl class="class">
<dt id="pstats.Stats">
<em class="property">class </em><code class="descclassname">pstats.</code><code class="descname">Stats</code><span class="sig-paren">(</span><em>*filenames or profile</em>, <em>stream=sys.stdout</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats" title="Permalink to this definition">¶</a></dt>
<dd><p>이 클래스 생성자는 <em>filename</em> 또는 <em>filename</em> 리스트나 <code class="xref py py-class docutils literal notranslate"><span class="pre">Profile</span></code> 인스턴스로부터
“통계 객체” 인스턴스를 생성한다. 출력은 <a href="#id8"><span class="problematic" id="id9">*</span></a>stream*에 지정된 스트림에 인쇄된다.</p>
<p>위 생성자에 의해 선택된 파일은 반드시 호환되는 버전의 <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>이나
<a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>에 의해 생성되어야 한다. 명확히 하자면 프로파일러의 향후
버전과의 파일 호환성은 보장되지 않고 서로 다른 프로파일러에 의해 생성된 파일들은
호환되지 않는다. 여러 파일이 제공되면 동일한 함수를 위한 모든 통계는 병합되어
여러 프로세스에 대한 보고가 하나의 리포트가 될 수 있게 한다. 기존 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a>
객체에 있는 데이터와 추가 파일이 병합되어야 하면 <a class="reference internal" href="#pstats.Stats.add" title="pstats.Stats.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a> 메서드를 사용한다.</p>
<p>파일 대신 <code class="xref py py-class docutils literal notranslate"><span class="pre">cProfile.Profile</span></code>나 <a class="reference internal" href="#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">profile.Profile</span></code></a> 객체를 소스로 사용해
프로파일 데이터를 읽을 수 있다.</p>
<p><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 객체는 다음 메서드를 갖는다.</p>
<dl class="method">
<dt id="pstats.Stats.strip_dirs">
<code class="descname">strip_dirs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.strip_dirs" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 클래스를 위한 이 메서드는 파일명 앞에 오는 모든 경로 정보를 삭제한다.
출력물의 사이즈를 줄여 80 컬럼 이내로 맞출 때 유용하다. 이 메서드는 객체를 수정하기
때문에 삭제된 정보는 손실된다. 삭제 작업을 한 후에는 객체의 항목들이 객체가 초기화 되고
로드되었을 때처럼 임의의 순서로 정렬된 것으로 간주된다. <a class="reference internal" href="#pstats.Stats.strip_dirs" title="pstats.Stats.strip_dirs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">strip_dirs()</span></code></a>
메서드로 인해 두개의 함수명이 같아지면 (같은 파일명, 같은 행에 있고 같은 함수명을 갖는 경우)
이 두 항목에 대한 통계는 하나의 항목에 대한 통계로 합쳐진다.</p>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>*filenames</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.add" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 클래스의 <code class="docutils literal notranslate"><span class="pre">add</span></code> 메서드는 추가 프로파일링 정보를 현재 프로파일링 객체에 합친다.
인수가 지정하는 파일은 호환되는 <a class="reference internal" href="#profile.run" title="profile.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">profile.run()</span></code></a>이나 <code class="xref py py-func docutils literal notranslate"><span class="pre">cProfile.run()</span></code> 버전에 의해
생성되어야 한다. 같은 이름 (같은 파일, 행, 이름)을 갖는 함수에 대한 통계는 자동으로 하나의 함수 통계에 합쳐진다.</p>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.dump_stats">
<code class="descname">dump_stats</code><span class="sig-paren">(</span><em>filename</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.dump_stats" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 객체에 로드된 데이터를 <em>filename</em> 인수에 지정된 파일에 저장한다.
지정된 파일이 존재하지 않으면 생성되고 이미 있는 파일인 경우에는 덮어쓴다.
<a class="reference internal" href="#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">profile.Profile</span></code></a>, <code class="xref py py-class docutils literal notranslate"><span class="pre">cProfile.Profile</span></code> 클래스에 있는 같은 이름의 메서드와 동일하다.</p>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.sort_stats">
<code class="descname">sort_stats</code><span class="sig-paren">(</span><em>*keys</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.sort_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>이 메서드는 주어진 기준에 따라 <a class="reference internal" href="#pstats.Stats" title="pstats.Stats"><code class="xref py py-class docutils literal notranslate"><span class="pre">Stats</span></code></a> 객체를 정렬한다.
인수는 일반적으로 정렬 기준을 나타내는 문자열이다. (예시: <code class="docutils literal notranslate"><span class="pre">time</span></code>, <code class="docutils literal notranslate"><span class="pre">name</span></code>)</p>
<p>하나 이상의 키가 주어지고 이전에 선택된 모든 키가 동일하면 추가 키는 두번째 정렬 기준으로 사용된다.
예를 들어, <code class="docutils literal notranslate"><span class="pre">sort_stats('name',</span> <span class="pre">'file')</span></code>는 모든 항목을 함수 이름에 따라 정렬하고 함수 이름으로
정렬된 묶음이 파일명에 따라 정렬된다.</p>
<p>약자명이 모호하지 않는 한 모든 키에 약자를 사용할 수 있다. 다음은 현재 정의된 키다.</p>
<table border="1" class="docutils">
<colgroup>
<col width="45%" />
<col width="55%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Valid Arg</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'calls'</span></code></td>
<td>호출 횟수</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'cumulative'</span></code></td>
<td>누적 시간</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'cumtime'</span></code></td>
<td>누적 시간</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'file'</span></code></td>
<td>파일명</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'filename'</span></code></td>
<td>파일명</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'module'</span></code></td>
<td>파일명</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'ncalls'</span></code></td>
<td>호출 횟수</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'pcalls'</span></code></td>
<td>primitive 호출 횟수</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'line'</span></code></td>
<td>행 번호</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'name'</span></code></td>
<td>함수명</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'nfl'</span></code></td>
<td>이름/파일/행</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'stdname'</span></code></td>
<td>표준 이름</td>
</tr>
<tr class="row-even"><td><code class="docutils literal notranslate"><span class="pre">'time'</span></code></td>
<td>인터널 타임</td>
</tr>
<tr class="row-odd"><td><code class="docutils literal notranslate"><span class="pre">'tottime'</span></code></td>
<td>인터널 타임</td>
</tr>
</tbody>
</table>
<p>통계에 대한 모든 정렬은 내림차순으로 정렬된다. (시간이 오래 걸린 것이 가장 위에 온다.)
함수명, 파일명, 행 번호에 대한 정렬은 알파벳 기준으로 오름차순이다. <code class="docutils literal notranslate"><span class="pre">'nfl'</span></code>과 <code class="docutils literal notranslate"><span class="pre">'stdname'</span></code>의
미묘한 차이는 표준 이름이 인쇄되는 이름으로 정렬된다는 것이다. 따라서 행번호는 이상한 방식으로 정렬된다.
예를 들어, 행 번호 3, 20, 40은 같은 파일명을 가질 때 20, 3, 40 순서로 나타난다. 반대로 <code class="docutils literal notranslate"><span class="pre">'nfl'</span></code>은
행 번호의 숫자를 비교해 정렬한다. 사실 <code class="docutils literal notranslate"><span class="pre">sort_stats('nfl')</span></code>는 <code class="docutils literal notranslate"><span class="pre">sort_stats('name',</span> <span class="pre">'file','line')</span></code>와 같다.</p>
<p>하위 호환성으로 인해 숫자 인수 <code class="docutils literal notranslate"><span class="pre">-1</span></code>, <code class="docutils literal notranslate"><span class="pre">0</span></code>, <code class="docutils literal notranslate"><span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">2</span></code>가 허용된다.
각 숫자 인수는 <code class="docutils literal notranslate"><span class="pre">'stdname'</span></code>, <code class="docutils literal notranslate"><span class="pre">'calls'</span></code>, <code class="docutils literal notranslate"><span class="pre">'time'</span></code>, <code class="docutils literal notranslate"><span class="pre">'cumulative'</span></code>로 해석된다.
이러한 이전 스타일 포맷이 사용되면 숫자 인수만이 분류 키로 사용되고 추가 인수는 무시된다.</p>
</dd></dl>

<dl class="method">
<dt id="pstats.Stats.reverse_order">
<code class="descname">reverse_order</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pstats.Stats.reverse_order" title="Permalink to this definition">¶</a></dt>
<dd><p>이 메서드는 객체 내부의 기본 목록을 반대로 정렬한다.
기본이 되는 오름, 내림 차순은 분류 키 선택에 따라 결정된다.</p>
</dd></dl>

</dd></dl>

<p>profiler.</p>
<blockquote>
<div><dl class="method">
<dt id="pstats.print_stats">
<code class="descclassname">pstats.</code><code class="descname">print_stats</code><span class="sig-paren">(</span><em>*restrictions</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.print_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>이 메서드는 <a class="reference internal" href="#profile.run" title="profile.run"><code class="xref py py-func docutils literal notranslate"><span class="pre">profile.run()</span></code></a> 정의에 설명된 대로 리포트를 인쇄한다.</p>
<p>인쇄되는 순서는 개체에 마지막으로 행해진 <a class="reference internal" href="#pstats.Stats.sort_stats" title="pstats.Stats.sort_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">sort_stats()</span></code></a>  작업에 기반해 결정된다.
(<a class="reference internal" href="#pstats.Stats.add" title="pstats.Stats.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a>, <a class="reference internal" href="#pstats.Stats.strip_dirs" title="pstats.Stats.strip_dirs"><code class="xref py py-meth docutils literal notranslate"><span class="pre">strip_dirs()</span></code></a>에 있는 주의 사항을 따른다.)</p>
<p>인수가 주어지면 목록이 중요한 항목들만 포함하게 제한하는데 사용될 수 있다. 초기 목록은
프로파일된 함수의 전체 집합이 된다. 각 제한 조건은 행 수를 선택하기 위한 정수, 제한할 행의
비율을 선택하기 위한 0.0과 1.0 사이의 소수, 또는 정규 표현식으로 해석되는 문자열이 될 수 있다.
(정규 표현식은 출력될 표준 이름을 분류한다.) 여러 제한 조건이 주어지면 순서대로 적용된다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">print_stats</span><span class="p">(</span><span class="o">.</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;foo:&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>위 예시는 목록의 상위 10% 항목으로 제한하고 이 중에 파일명이 <code class="file docutils literal notranslate"><span class="pre">.*foo:</span></code>를 포함하는 함수만을 출력한다.</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">print_stats</span><span class="p">(</span><span class="s1">&#39;foo:&#39;</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>반대로 위 예시는 파일명이 <code class="file docutils literal notranslate"><span class="pre">.*foo:</span></code>를 포함하는 함수로 제한하고 여기에서 상위 10%만을 출력한다.</p>
</dd></dl>

<dl class="method">
<dt id="pstats.print_callers">
<code class="descclassname">pstats.</code><code class="descname">print_callers</code><span class="sig-paren">(</span><em>*restrictions</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.print_callers" title="Permalink to this definition">¶</a></dt>
<dd><p>이 메서드는 프로파일된 데이터베이스에 있는 각 함수를 호출한 모든 함수 목록을 출력한다.
정렬 순서는 <a class="reference internal" href="profile.html#pstats.Stats.print_stats" title="pstats.Stats.print_stats"><code class="xref py py-meth docutils literal notranslate"><span class="pre">print_stats()</span></code></a>에 주어진 것과 동일하고 제한 조건 인수의 정의도 동일하다.
각 호출기는 자신의 행에 리포트된다. 포맷은 통계를 만들어내는 프로파일러에 따라 조금 달라진다.</p>
<ul class="simple">
<li><a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>를 사용하면 각 호출기 다음 괄호 안에 숫자가 표시되고 특정 호출이 생성된 횟수를 나타낸다.
편의를 위해 오른쪽에 함수에 사용된 누적 시간이 괄호 없이 나타난다.</li>
<li><a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>을 사용하면 각 호출기 앞에 세개의 숫자가 나타난다.
특정 호출이 생성된 횟수, 현재 함수가 이 호출기에 의해 호출된 동안 사용한 총 시간과 누적 시간.</li>
</ul>
</dd></dl>

<dl class="method">
<dt id="pstats.print_callees">
<code class="descclassname">pstats.</code><code class="descname">print_callees</code><span class="sig-paren">(</span><em>*restrictions</em><span class="sig-paren">)</span><a class="headerlink" href="#pstats.print_callees" title="Permalink to this definition">¶</a></dt>
<dd><p>지정된 함수에 의해 호출된 모든 함수의 목록을 인쇄한다. 호출의 방향은 반대지만 (호출하는 것과 호출되는 것)
사용되는 인수와 정렬는 <a class="reference internal" href="profile.html#pstats.Stats.print_callers" title="pstats.Stats.print_callers"><code class="xref py py-meth docutils literal notranslate"><span class="pre">print_callers()</span></code></a>와 동일하다.</p>
</dd></dl>

</div></blockquote>
</div>
<div class="section" id="deterministic-profiling">
<span id="id10"></span><h2>4.1.5. 결정론적 프로파일링이란?<a class="headerlink" href="#deterministic-profiling" title="Permalink to this headline">¶</a></h2>
<p><em class="dfn">결정론적 프로파일링</em>이란 모든 <em>함수 호출</em> <em>함수 반환</em>, <em>예외</em> 이벤트가 모니터링되고
(사용자의 코드가 실행되는 동안) 각 이벤트 간에 정확한 시간 측정이 이루어진다는 의미다.
반대로 (이 모듈이 하지 않는) <em class="dfn">통계적 프로파일링</em>이란 유효한 명령 포인터를 임의로 샘플링하고
사용되는 시간을 추정한다. 후자의 기술은 코드를 계측하지 않아도 되기 때문에 일반적으로
오버헤드가 적지만 사용되는 시간에 대한 상대적인 지표를 제공한다.</p>
<p>파이썬에는 실행중에 활성화되는 해석기가 있기 때문에 결정론적 프로파일링을 위해 계측된 코드가 없어도 된다.
파이썬은 자동으로 각 이벤트에 대해 <em class="dfn">hook</em>(선택 콜백)을 제공한다. 추가로 파이썬의 해석되는 특성으로 인해
실행에 많은 오버헤드가 가해지기 때문에 결정론적 프로파일링은 일반적인 어플리케이션에서 적은 프로세싱 오버헤드를 준다.
결과적으로 결정론적 프로파일링은 큰 비용 없이 실행 시간에 대한 폭넓은 통계를 제공한다.</p>
<p>호출 횟수 통계는 코드에 있는 버그나 (횟수가 이상한 경우) 인라인 확장 지점 (많은 호출 횟수가 많은 경우)을
인식하는데 사용될 수 있다. 내부 시간 통계는 주의깊게 최적화해야 하는 “핫 루프”를 인식하는데 사용될 수 있다.
누적 시간 통계는 알고리즘 선택과 관련된 높은 수준의 에러를 인식하는데 사용해야 한다.
누적 시간에 대한 특이한 처리로 알고리즘의 재귀 구현과 반복 구현을 직접 비교하기 위한 통계를 얻을 수 있다.</p>
</div>
<div class="section" id="profile-limitations">
<span id="id11"></span><h2>4.1.6. 한계점<a class="headerlink" href="#profile-limitations" title="Permalink to this headline">¶</a></h2>
<p>하나의 한계점은 시간 정보의 정확성이다. 결정론적 프로파일러의 정확성에 대한 근본적인 문제가 있다.
가장 분명한 제약은 내제된 “시계”가 일반적으로 약 .001초 단위로 간다는 것이다. 따라서 어떤 측정도
이 시계보다 정확할 수 없다. 만약 충분한 측정이 이루어지면 “에러”가 평균화 된다. 불행히도 이 첫번째
에러를 제거하면 두번째 에러가 나타난다.</p>
<p>두번째 문제는 이벤트가 보내지고 시간을 얻기 위한 프로파일러의 호출이 실제로 시계의 상태를 얻을 때까지
시간이 걸린다는 것이다. 이와 유사하게 이벤트 핸들러를 종료할 때 시계의 값이 얻어질 때부터 사용자의 코드가
다시 실행될 때까지 지연이 존재한다. 그 결과 여러번 호출되거나 많은 함수를 호출하는 함수는 일반적으로
이러한 에러를 축적한다. 이러한 방식으로 축적되는 에러는 일반적으로 시계의 정확도보다 작지만 축적되면 심각해질 수 있다.</p>
<p>문제는 오버헤드가 적은 <a class="reference internal" href="#module-cProfile" title="cProfile"><code class="xref py py-mod docutils literal notranslate"><span class="pre">cProfile</span></code></a>보다 <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>에서 더 중요하다. 이러한 이유로 <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a>은
몇몇 플랫폼에서 보정 수단을 제공해 에러가 통계적으로(평균으로) 제거될 수 있게 한다. 프로파일러가 보정되고 나면
(최소한 제곱 센스에서) 더 정확해지지만 종종 음수를 주기도 한다. (호출 횟수가 예외적으로 낮을 때) 프로파일에
음수가 나타나도 놀라지 말자. 프로파일러를 보정했을 때만 나타나며 보정하지 않은 결과보다 정확하다.</p>
</div>
<div class="section" id="calibration">
<span id="profile-calibration"></span><h2>4.1.7. Calibration<a class="headerlink" href="#calibration" title="Permalink to this headline">¶</a></h2>
<p>The profiler of the <a class="reference internal" href="#module-profile" title="profile: Python source profiler."><code class="xref py py-mod docutils literal notranslate"><span class="pre">profile</span></code></a> module subtracts a constant from each event
handling time to compensate for the overhead of calling the time function, and
socking away the results.  By default, the constant is 0. The following
procedure can be used to obtain a better constant for a given platform (see
<a class="reference internal" href="#profile-limitations"><span class="std std-ref">한계점</span></a>).</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">profile</span>
<span class="n">pr</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">pr</span><span class="o">.</span><span class="n">calibrate</span><span class="p">(</span><span class="mi">10000</span><span class="p">))</span>
</pre></div>
</div>
<p>The method executes the number of Python calls given by the argument, directly
and again under the profiler, measuring the time for both. It then computes the
hidden overhead per profiler event, and returns that as a float.  For example,
on a 1.8Ghz Intel Core i5 running Mac OS X, and using Python’s time.process_time() as
the timer, the magical number is about 4.04e-6.</p>
<p>The object of this exercise is to get a fairly consistent result. If your
computer is <em>very</em> fast, or your timer function has poor resolution, you might
have to pass 100000, or even 1000000, to get consistent results.</p>
<p>When you have a consistent answer, there are three ways you can use it:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">profile</span>

<span class="c1"># 1. Apply computed bias to all Profile instances created hereafter.</span>
<span class="n">profile</span><span class="o">.</span><span class="n">Profile</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">your_computed_bias</span>

<span class="c1"># 2. Apply computed bias to a specific Profile instance.</span>
<span class="n">pr</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">Profile</span><span class="p">()</span>
<span class="n">pr</span><span class="o">.</span><span class="n">bias</span> <span class="o">=</span> <span class="n">your_computed_bias</span>

<span class="c1"># 3. Specify computed bias in instance constructor.</span>
<span class="n">pr</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">Profile</span><span class="p">(</span><span class="n">bias</span><span class="o">=</span><span class="n">your_computed_bias</span><span class="p">)</span>
</pre></div>
</div>
<p>If you have a choice, you are better off choosing a smaller constant, and then
your results will “less often” show up as negative in profile statistics.</p>
</div>
<div class="section" id="using-a-custom-timer">
<span id="profile-timers"></span><h2>4.1.8. Using a custom timer<a class="headerlink" href="#using-a-custom-timer" title="Permalink to this headline">¶</a></h2>
<p>If you want to change how current time is determined (for example, to force use
of wall-clock time or elapsed process time), pass the timing function you want
to the <code class="xref py py-class docutils literal notranslate"><span class="pre">Profile</span></code> class constructor:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pr</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">Profile</span><span class="p">(</span><span class="n">your_time_func</span><span class="p">)</span>
</pre></div>
</div>
<p>The resulting profiler will then call <code class="docutils literal notranslate"><span class="pre">your_time_func</span></code>. Depending on whether
you are using <a class="reference internal" href="#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">profile.Profile</span></code></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">cProfile.Profile</span></code>,
<code class="docutils literal notranslate"><span class="pre">your_time_func</span></code>’s return value will be interpreted differently:</p>
<dl class="docutils">
<dt><a class="reference internal" href="#profile.Profile" title="profile.Profile"><code class="xref py py-class docutils literal notranslate"><span class="pre">profile.Profile</span></code></a></dt>
<dd><p class="first"><code class="docutils literal notranslate"><span class="pre">your_time_func</span></code> should return a single number, or a list of numbers whose
sum is the current time (like what <a class="reference internal" href="os.html#os.times" title="os.times"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.times()</span></code></a> returns).  If the
function returns a single time number, or the list of returned numbers has
length 2, then you will get an especially fast version of the dispatch
routine.</p>
<p class="last">Be warned that you should calibrate the profiler class for the timer function
that you choose (see <a class="reference internal" href="#profile-calibration"><span class="std std-ref">Calibration</span></a>).  For most machines, a timer
that returns a lone integer value will provide the best results in terms of
low overhead during profiling.  (<a class="reference internal" href="os.html#os.times" title="os.times"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.times()</span></code></a> is <em>pretty</em> bad, as it
returns a tuple of floating point values).  If you want to substitute a
better timer in the cleanest fashion, derive a class and hardwire a
replacement dispatch method that best handles your timer call, along with the
appropriate calibration constant.</p>
</dd>
<dt><code class="xref py py-class docutils literal notranslate"><span class="pre">cProfile.Profile</span></code></dt>
<dd><p class="first"><code class="docutils literal notranslate"><span class="pre">your_time_func</span></code> should return a single number.  If it returns integers,
you can also invoke the class constructor with a second argument specifying
the real duration of one unit of time.  For example, if
<code class="docutils literal notranslate"><span class="pre">your_integer_time_func</span></code> returns times measured in thousands of seconds,
you would construct the <code class="xref py py-class docutils literal notranslate"><span class="pre">Profile</span></code> instance as follows:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">pr</span> <span class="o">=</span> <span class="n">cProfile</span><span class="o">.</span><span class="n">Profile</span><span class="p">(</span><span class="n">your_integer_time_func</span><span class="p">,</span> <span class="mf">0.001</span><span class="p">)</span>
</pre></div>
</div>
<p class="last">As the <code class="xref py py-class docutils literal notranslate"><span class="pre">cProfile.Profile</span></code> class cannot be calibrated, custom timer
functions should be used with care and should be as fast as possible.  For
the best results with a custom timer, it might be necessary to hard-code it
in the C source of the internal <code class="xref py py-mod docutils literal notranslate"><span class="pre">_lsprof</span></code> module.</p>
</dd>
</dl>
<p>Python 3.3 adds several new functions in <a class="reference internal" href="time.html#module-time" title="time: Time access and conversions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">time</span></code></a> that can be used to make
precise measurements of process or wall-clock time. For example, see
<a class="reference internal" href="time.html#time.perf_counter" title="time.perf_counter"><code class="xref py py-func docutils literal notranslate"><span class="pre">time.perf_counter()</span></code></a>.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../contents.html">목차</a></h3>
  <ul>
<li><a class="reference internal" href="#">4.1. 파이썬 프로파일러</a><ul>
<li><a class="reference internal" href="#profiler-introduction">4.1.1. 프로파일러 소개</a></li>
<li><a class="reference internal" href="#profile-instant">4.1.2. 즉석 사용자 매뉴얼</a></li>
<li><a class="reference internal" href="#module-cProfile">4.1.3. <code class="docutils literal notranslate"><span class="pre">profile</span></code>, <code class="docutils literal notranslate"><span class="pre">cProfile</span></code> 모듈 레퍼런스</a></li>
<li><a class="reference internal" href="#stats">4.1.4. <code class="docutils literal notranslate"><span class="pre">Stats</span></code> 클래스</a></li>
<li><a class="reference internal" href="#deterministic-profiling">4.1.5. 결정론적 프로파일링이란?</a></li>
<li><a class="reference internal" href="#profile-limitations">4.1.6. 한계점</a></li>
<li><a class="reference internal" href="#calibration">4.1.7. Calibration</a></li>
<li><a class="reference internal" href="#using-a-custom-timer">4.1.8. Using a custom timer</a></li>
</ul>
</li>
</ul>

  <h4>이전 주제</h4>
  <p class="topless"><a href="pdb.html"
                        title="이전 장">27.3. <code class="docutils literal notranslate"><span class="pre">pdb</span></code> — The Python Debugger</a></p>
  <h4>다음 주제</h4>
  <p class="topless"><a href="timeit.html"
                        title="다음 장">27.5. <code class="docutils literal notranslate"><span class="pre">timeit</span></code> — Measure execution time of small code snippets</a></p>
  <div role="note" aria-label="source link">
    <h3>이 페이지</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">버그 보고</a></li>
      <li>
        <a href="https://github.com/VeranosTech/docs-korean-cpython/blob/gh-pages/Doc/library/profile_ko.rst"
            rel="nofollow">본문의 소스코드
        </a>
      </li>
    </ul>
  </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="timeit.html" title="27.5. timeit — Measure execution time of small code snippets"
             >next</a> |</li>
        <li class="right" >
          <a href="pdb.html" title="27.3. pdb — The Python Debugger"
             >previous</a> |</li>
        <li><img src="../_static/py.png" alt=""
                 style="vertical-align: middle; margin-top: -1px"/></li>
        <li><a href="https://www.python.org/">Python</a> &#187;</li>
        <li>
          <a href="../index.html">3.8.0a0 문서</a> &#187;
        </li>

          <li class="nav-item nav-item-1"><a href="index_ko.html" >파이썬 표준 라이브러리</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="debug_ko.html" >4. 디버깅과 프로파일링</a> &#187;</li>
    <li class="right">
        

    <div class="inline-search" style="display: none" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="Quick search" type="text" name="q" />
          <input type="submit" value="Go" />
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
    </div>
    <script type="text/javascript">$('.inline-search').show(0);</script>
         |
    </li>

      </ul>
    </div>  
    <div class="footer">
    &copy; <a href="../copyright.html">Copyright</a> 2001-2018, 파이썬 소프트웨어 재단.
    <br />
    The Python Software Foundation is a non-profit corporation.
    <a href="https://www.python.org/psf/donations/">Please donate.</a>
    <br />
    Last updated on Jul 13, 2018.
    <a href="../bugs.html">Found a bug</a>?
    <br />
    Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.7.5.
    </div>

  </body>
</html>